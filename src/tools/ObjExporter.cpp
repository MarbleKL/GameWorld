#include "tools/ObjExporter.h"
#include <fstream>
#include <iomanip>

bool ObjExporter::ExportAvatar(
    const std::string& base_filename,
    const std::vector<MeshData>& meshes,
    const std::string& output_dir
) {
    if (meshes.empty()) {
        return false;
    }
    
    std::string obj_path = output_dir + "/" + base_filename + ".obj";
    std::string mtl_path = output_dir + "/" + base_filename + ".mtl";
    std::string mtl_filename = base_filename + ".mtl";
    
    // 打开 OBJ 文件
    std::ofstream obj_file(obj_path);
    if (!obj_file.is_open()) {
        return false;
    }
    
    // 打开 MTL 文件
    std::ofstream mtl_file(mtl_path);
    if (!mtl_file.is_open()) {
        obj_file.close();
        return false;
    }
    
    // 写入 OBJ 文件头
    obj_file << "# Wavefront OBJ file\n";
    obj_file << "# Generated by GameWorld Model Generator\n";
    obj_file << "# Avatar: " << base_filename << "\n";
    obj_file << "mtllib " << mtl_filename << "\n\n";
    
    // 写入 MTL 文件头
    mtl_file << "# Wavefront MTL file\n";
    mtl_file << "# Generated by GameWorld Model Generator\n\n";
    
    int vertex_offset = 1;  // OBJ 使用 1-based 索引
    int normal_offset = 1;
    
    // 遍历每个 Mesh 部件
    for (size_t mesh_idx = 0; mesh_idx < meshes.size(); ++mesh_idx) {
        const MeshData& mesh = meshes[mesh_idx];
        
        // 为每个 Mesh 创建一个分组
        obj_file << "# Mesh Part " << mesh_idx << "\n";
        obj_file << "g mesh_part_" << mesh_idx << "\n";
        
        // 为这个 Mesh 创建材质（使用平均颜色）
        std::string material_name = "material_" + std::to_string(mesh_idx);
        Color avg_color = CalculateAverageColor(mesh);
        
        mtl_file << "newmtl " << material_name << "\n";
        mtl_file << "Ka " << avg_color.r << " " << avg_color.g << " " << avg_color.b << "\n";  // Ambient
        mtl_file << "Kd " << avg_color.r << " " << avg_color.g << " " << avg_color.b << "\n";  // Diffuse
        mtl_file << "Ks 0.5 0.5 0.5\n";  // Specular
        mtl_file << "Ns 32.0\n";          // Shininess
        mtl_file << "\n";
        
        // 使用材质
        obj_file << "usemtl " << material_name << "\n";
        
        // 写入顶点位置
        for (const Vec3& v : mesh.positions) {
            obj_file << "v " << std::fixed << std::setprecision(6) 
                     << v.x << " " << v.y << " " << v.z << "\n";
        }
        
        // 写入法线
        for (const Vec3& n : mesh.normals) {
            obj_file << "vn " << std::fixed << std::setprecision(6)
                     << n.x << " " << n.y << " " << n.z << "\n";
        }
        
        // 写入面（三角形）
        // OBJ 格式: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
        // 我们没有UV，所以使用: f v1//vn1 v2//vn2 v3//vn3
        for (size_t i = 0; i < mesh.indices.size(); i += 3) {
            uint32_t i0 = mesh.indices[i] + vertex_offset;
            uint32_t i1 = mesh.indices[i + 1] + vertex_offset;
            uint32_t i2 = mesh.indices[i + 2] + vertex_offset;
            
            // 对应的法线索引（假设法线和顶点一一对应）
            uint32_t n0 = mesh.indices[i] + normal_offset;
            uint32_t n1 = mesh.indices[i + 1] + normal_offset;
            uint32_t n2 = mesh.indices[i + 2] + normal_offset;
            
            obj_file << "f " << i0 << "//" << n0 << " "
                     << i1 << "//" << n1 << " "
                     << i2 << "//" << n2 << "\n";
        }
        
        obj_file << "\n";
        
        // 更新偏移量
        vertex_offset += mesh.positions.size();
        normal_offset += mesh.normals.size();
    }
    
    obj_file.close();
    mtl_file.close();
    
    return true;
}

Color ObjExporter::CalculateAverageColor(const MeshData& mesh) {
    if (mesh.colors.empty()) {
        return Color{0.8f, 0.8f, 0.8f, 1.0f};  // 默认灰色
    }
    
    float r = 0.0f, g = 0.0f, b = 0.0f;
    for (const Color& c : mesh.colors) {
        r += c.r;
        g += c.g;
        b += c.b;
    }
    
    size_t count = mesh.colors.size();
    return Color{r / count, g / count, b / count, 1.0f};
}
