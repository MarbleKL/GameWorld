# ERPE 世界下的基因与几何/角色生成子系统设计（新版）

> 目标：明确“参与游戏逻辑的基因”和“纯外观参数”的关系，  
在保持 ERPE 生态/势力逻辑独立的前提下，  
提供一套可复用的几何/角色生成流程。

---

## 0. 总体设计原则

1. **基因分层但数据一源**  
    - 用一份“逻辑基因（GameplayGene）”作为权威，  

        既参与攻击力、速度等逻辑，又为外观提供基础参数。
    - 外观基因（AppearanceGene）由逻辑基因**推导+少量视觉随机**产生。
2. **逻辑层与几何层解耦**  
    - ERPE 负责：物种、个体、种群、势力、行为、数值。
    - 几何子系统负责：Mesh / Skeleton / Avatar 资源。
    - 通过桥接层用基因把两者串起来。
3. **引擎无关的几何核心 + 渲染适配层**  
    - 核心只产生 MeshData / Skeleton 等纯数据。
    - 具体引擎（Godot/Unreal/自研）用适配层上传到 GPU。

---

## 1. 数据层次总览

### 1.1 逻辑基因（GameplayGene）

参与**数值计算、物理行为、AI**，是基因的权威来源。

```C++
using SpeciesId = uint32_t;

struct GameplayGene {
    SpeciesId species_id;
    uint32_t  seed;          // 个体基因随机源

    // [shared] 逻辑+视觉都会用的字段
    float limb_length;       // 四肢长度 → 攻击距离 / 步幅 + 外观身高/手脚比例
    float body_mass;         // 体重 → 惯性 / 撞击 + 外观胖瘦感
    float size_scale;        // 整体尺度 → 碰撞体 / 体型 + 模型缩放

    // [logic-only] 只用于数值/AI，不直接映射到几何
    float base_strength;     // 力量：攻击力、负重
    float base_agility;      // 敏捷：移动速度、闪避
    float base_endurance;    // 体力：耐久、精力
    float base_intellect;    // 智力：技能、魔法、策略

    // 物种特有的遗传开关（逻辑上需要知道）
    bool  has_wings;         // 会不会飞
    bool  has_horn;          // 有没有角（撞击攻击）
    // ...
};
```

> 标记说明：
- `[shared]` 字段会影响外观（AppearanceGene 会用到）；
- `[logic-only]` 字段只在逻辑计算中使用。

---

### 1.2 外观基因（AppearanceGene）

**只用于外观生成**，从 GameplayGene 映射而来，再加少量随机。

```C++
struct AppearanceGene {
    SpeciesId species_id;
    uint32_t  seed;      // 可由 GameplayGene.seed 派生

    // 从 GameplayGene（共享字段）映射 + 随机扰动
    float height;        // ~ limb_length + size_scale
    float fatness;       // ~ body_mass / height
    float musculature;   // ~ base_strength 映射为视觉肌肉感

    // 完全视觉用字段（不参与逻辑）
    float base_tone;          // 皮肤 / 毛发基础颜色
    float pattern_variation;  // 花纹变化
    float scar_level;         // 伤疤程度
    // 发型/服装/饰品标签，可由势力/职业决定
    std::vector<std::string> style_tags;
};
```

示例：从逻辑基因推导外观基因（桥接函数）：

```C++
AppearanceGene build_appearance_from_gameplay(
    const GameplayGene& gg,
    uint32_t visual_seed
) {
    AppearanceGene ag;
    ag.species_id = gg.species_id;
    ag.seed       = visual_seed;

    // 逻辑参数 → 外观参数
    ag.height      = gg.limb_length * 0.5f + gg.size_scale * 0.5f;
    ag.fatness     = gg.body_mass / std::max(ag.height, 0.1f);
    ag.musculature = gg.base_strength;  // 或某个压缩映射函数

    // 纯视觉随机（不回写逻辑）
    ag.base_tone          = random01(ag.seed + 1);
    ag.pattern_variation  = random01(ag.seed + 2);
    ag.scar_level         = random01(ag.seed + 3);

    return ag;
}
```

---

### 1.3 衍生数值（Runtime Stats）

由 GameplayGene + 其他逻辑状态（等级、装备等）计算得到。

```C++
struct C_Stats {
    float attack_power;
    float move_speed;
    float max_health;
    // ...
};
```

计算示例：

```C++
void RecalcStatsFromGene(EntityId e) {
    const auto& gg = get<C_GameplayGene>(e).gene;
    auto& st = get<C_Stats>(e);

    st.attack_power = f_attack(gg.base_strength, gg.species_id);
    st.move_speed   = f_speed(gg.base_agility, gg.body_mass);
    st.max_health   = f_health(gg.base_endurance, gg.size_scale);
}
```

> 注意：**逻辑权威是 GameplayGene 和 C_Stats**，
AppearanceGene 不参与任何数值计算。

---

### 1.4 几何结果（MeshData / Skeleton / AvatarBundle）

几何子系统输出的纯数据，用于渲染。

```C++
struct Vec2 { float x, y; };
struct Vec3 { float x, y, z; };
struct Vec4 { float x, y, z, w; };

struct Color { float r, g, b, a; };

struct Mat4 { float m[16]; };

struct VertexWeight {
    uint16_t bone_indices[4];
    float    weights[4];
};

struct MeshData {
    std::vector<Vec3>          positions;
    std::vector<Vec3>          normals;
    std::vector<Vec2>          uvs;
    std::vector<Color>         colors;        // 可选
    std::vector<Vec4>          tangents;      // 可选
    std::vector<VertexWeight>  skin;          // 可选
    std::vector<uint32_t>      indices;
};

struct Bone {
    std::string name;
    int         parent;    // -1 -> root
    Mat4        bind_pose;
};

struct Skeleton {
    std::vector<Bone> bones;
};

struct AvatarBundle {
    Skeleton                skeleton;
    std::vector<MeshData>  meshes;
};
```

几何生成接口：

```C++
class IAvatarGenerator {
public:
    virtual ~IAvatarGenerator() = default;
    virtual AvatarBundle generate(const AppearanceGene& gene) = 0;
};
```

---

## 2. Entity 组件设计（以 Creature 为例）

### 2.1 逻辑相关组件

```C++
struct C_GameplayGene {
    GameplayGene gene;
};

struct C_Stats {
    float attack_power;
    float move_speed;
    float max_health;
    // ...
};

struct C_CreatureLife {
    float age;
    float hunger;
    float fatigue;
    // ...
};

struct C_SpeciesRef {
    SpeciesId species_id;
};

struct C_FactionRef {
    uint32_t faction_id;
};

struct C_Traits {
    float aggression;
    float sociability;
    float bravery;
    // ...
};
```

### 2.2 外观与渲染组件

```C++
using AvatarId = uint64_t;

struct C_Appearance {
    AppearanceGene gene;  // 由 GameplayGene 推导
    AvatarId       avatar; // 几何生成+上传后的句柄（可为 0 表示尚未生成）
};
```

---

## 3. 生命周期与流程

### 3.1 个体生成（出生 / 刷怪）

1. 确定物种 `SpeciesId`。
2. 生成 `GameplayGene`：  
    - 若有父母：从父母 GameplayGene 进行遗传 + 变异；  
    - 若无父母：从物种默认基因模板 + 随机生成。
3. 创建 `C_GameplayGene` 组件。
4. 调用 `RecalcStatsFromGene` 填充 `C_Stats`。
5. 此时**不需要**立刻生成外观和 Mesh，可延迟到“需要渲染时”。

### 3.2 首次渲染时生成外观与模型

在视野/距离检测中触发：

1. 若实体没有 `C_Appearance`：
    - 根据 `C_GameplayGene` 调用 `build_appearance_from_gameplay` 得到 `AppearanceGene`；
    - 调用 `IAvatarGenerator::generate(AppearanceGene)` 得到 `AvatarBundle`；
    - 把 `AvatarBundle`交给渲染适配层生成 `AvatarId`；
    - 添加 `C_Appearance`，保存 `gene` 和 `avatar`。
2. 之后每帧渲染使用缓存的 `avatar` 即可。

> 逻辑层完全可以在没有 C_Appearance 的情况下运行  
（比如远距离只用种群统计，不加载个体模型）。

---

## 4. Population（种群）的视觉表现

### 4.1 Population 逻辑仍然基于统计

```C++
struct C_Population {
    SpeciesId species_id;
    uint32_t  estimated_count;
    // 统计意义上的平均/方差，可来自 GameplayGene 的分布
    float avg_limb_length;
    float avg_body_mass;
    float avg_size_scale;
    // ...
};
```

### 4.2 方案 A：代表个体样本（Sample-based）

为每个 Population 维护少量“代表性外观样本”：

```C++
struct C_PopulationVisual {
    std::vector<AppearanceGene> sample_genes;
    std::vector<AvatarId>       sample_avatars;
};
```

流程示例：

1. Population 初始化/更新时：  

    根据 `avg_limb_length` / `avg_body_mass` 等统计值生成若干 “虚拟 GameplayGene”，  

    再用同样的 `build_appearance_from_gameplay` → 得到 `sample_genes`。
2. 调用 `IAvatarGenerator` 为这些样本生成 `sample_avatars`。
3. 远景渲染时，以低密度/LOD 的方式摆放这些 sample 作为“远处的那群生物”。

### 4.3 方案 B：种群级 Mesh 生成器（Cluster-based）

为远景场景定义一个专门接口：

```C++
struct PopulationVisualParams {
    SpeciesId   species_id;
    uint32_t    seed;
    float       density;
    uint32_t    estimated_count;

    // 可选：平均基因参数影响群体整体外观
    float       avg_limb_length;
    float       avg_body_mass;
    float       avg_size_scale;
};

class IPopulationVisualGenerator {
public:
    virtual ~IPopulationVisualGenerator() = default;
    virtual MeshData generate(const PopulationVisualParams& p) = 0;
};
```

- 输出可以是：
    - 一个远景群体 Mesh（比如一块草地上多只狼的简化模型）；
    - 或者一个 billboard/粒子系统用的几何表示。

---

## 5. 渲染适配层（Engine Adapter）

几何核心不依赖任何具体引擎，只输出 `AvatarBundle`。
要显示到屏幕上，需要适配层：

```C++
class IRenderAdapter {
public:
    virtual ~IRenderAdapter() = default;

    virtual AvatarId create_avatar(const AvatarBundle& bundle) = 0;
    // 可扩展：销毁、更新、LOD 等
};
```

- `GodotRenderAdapter`：`MeshData` → `ArrayMesh` / `Skeleton3D`；
- `UnrealRenderAdapter`：`MeshData` → `UStaticMesh` / `USkeletalMesh`；
- `CustomRenderAdapter`：上传到自研渲染后端。

---

## 6. 基因共享与职责边界

### 6.1 “共享基因字段”的规则

- 所有真实的遗传与数值，都定义在 `GameplayGene`。
- `[shared]` 字段用于：
    - 逻辑：攻击距离 / 速度 / 碰撞体等；
    - 外观：四肢长度 / 体型大小 / 胖瘦感等。
- AppearanceGene 不再定义新的“会改变数值”的字段。

### 6.2 数据流向（单向）

1. GameplayGene → C_Stats（数值计算）
2. GameplayGene → AppearanceGene（视觉映射 + 随机）
3. AppearanceGene → AvatarBundle（几何生成）
4. AvatarBundle → AvatarId（渲染适配上传）

> 逆向不允许：  
- 外观变化不会回写 GameplayGene；  
- 几何系统不修改 ERPE 的逻辑状态。

---

## 7. 设计规范小结

1. **逻辑基因是权威**  
    - 所有需要参与攻击力、速度等玩法的参数，都在 GameplayGene。  
    - AppearanceGene 只依赖 GameplayGene，不反向改变数值。
2. **外观与逻辑保持“看上去合理”**  
    - limb_length 大的个体：攻击距离更远 + 模型手脚更长。  
    - body_mass 高的个体：惯性更大 + 看上去更胖。
3. **生态/种群逻辑不依赖几何**  
    - Population 的数量、分布、繁殖死亡，都不依赖 Mesh。  
    - 视觉表现只是展示层，可用样本或群体 Mesh。
4. **几何核心引擎无关**  
    - `MeshData` / `Skeleton` / `AvatarBundle` 不包含任何渲染 API 类型。  
    - 渲染适配层负责“翻译”成 Godot/Unreal/自研的资源。

---

## 8. 后续可扩展方向（占位）

- 繁殖系统：从父母 `GameplayGene` 生成子代 `GameplayGene` 的规则（显性/隐性/变异率）；
- 基于势力/职业的外观标签映射：  

    `C_FactionRef` / 职业组件 → `AppearanceGene.style_tags`；
- LOD 策略：根据距离选择  

    “不渲染个体 → 只渲染 Population Mesh → 渲染代表个体 → 渲染全部个体”。

